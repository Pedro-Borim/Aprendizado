package br.com.adtsys.ciee.company.contractplaces.service;

import static java.util.Comparator.comparing;
import static java.util.Objects.nonNull;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import javax.persistence.EntityManager;
import javax.persistence.EntityNotFoundException;
import javax.persistence.PersistenceContext;
import javax.transaction.Transactional;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang3.BooleanUtils;
import org.apache.logging.log4j.util.Strings;
import org.javers.common.collections.Sets;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;

import br.com.adtsys.ciee.company.address.model.Address;
import br.com.adtsys.ciee.company.carteira.exception.CarteiraException;
import br.com.adtsys.ciee.company.carteira.model.Carteira;
import br.com.adtsys.ciee.company.carteira.repository.CarteiraRepository;
import br.com.adtsys.ciee.company.classcouncil.exception.ClassCouncilNotFoundException;
import br.com.adtsys.ciee.company.classcouncil.model.ClassCouncil;
import br.com.adtsys.ciee.company.classcouncil.repository.ClassCouncilRepository;
import br.com.adtsys.ciee.company.company.service.ProcuradorDadosEmpresaParticipanteContratoService;
import br.com.adtsys.ciee.company.configuracaoCobranca.exception.ConfiguracaoCobrancaException;
import br.com.adtsys.ciee.company.configuracaoCobranca.exception.ConfiguracaoCobrancaNotFoundException;
import br.com.adtsys.ciee.company.configuracaoCobranca.model.ConfiguracaoCobranca;
import br.com.adtsys.ciee.company.configuracaoCobranca.repository.ConfiguracaoCobrancaRepository;
import br.com.adtsys.ciee.company.contract.enumeration.CompanyTypeEnum;
import br.com.adtsys.ciee.company.contract.enumeration.ContractStatusEnum;
import br.com.adtsys.ciee.company.contract.model.CompanyContractInfo;
import br.com.adtsys.ciee.company.contract.model.CompanyContractInfoAddress;
import br.com.adtsys.ciee.company.contract.model.ComplementaryData;
import br.com.adtsys.ciee.company.contract.model.Contract;
import br.com.adtsys.ciee.company.contract.model.ContractInfo;
import br.com.adtsys.ciee.company.contract.repository.ContractInfoRepository;
import br.com.adtsys.ciee.company.contract.service.ContractService;
import br.com.adtsys.ciee.company.contract.settings.dto.JovemTalentoDTO;
import br.com.adtsys.ciee.company.contract.settings.model.ContractSettings;
import br.com.adtsys.ciee.company.contract.settings.model.DocumentType;
import br.com.adtsys.ciee.company.contract.settings.repository.ContractSettingsRepository;
import br.com.adtsys.ciee.company.contractplaces.blocking.exception.ContractPlaceBlockingReasonException;
import br.com.adtsys.ciee.company.contractplaces.blocking.model.ContractPlaceBlockingReason;
import br.com.adtsys.ciee.company.contractplaces.blocking.repository.ContractPlaceBlockingReasonRepository;
import br.com.adtsys.ciee.company.contractplaces.dto.LocalContratoDropdownDTO;
import br.com.adtsys.ciee.company.contractplaces.enumeration.ContractPlacesEnum;
import br.com.adtsys.ciee.company.contractplaces.exception.ContractPlacesCnpjValidateException;
import br.com.adtsys.ciee.company.contractplaces.exception.ContractPlacesInscricaoEstadualException;
import br.com.adtsys.ciee.company.contractplaces.exception.ContratoDevePossuirNoMinimoUmLocalException;
import br.com.adtsys.ciee.company.contractplaces.exception.InvalidContractPlacesParamsException;
import br.com.adtsys.ciee.company.contractplaces.exception.LocalContatoSemDocumentoObrigatorioException;
import br.com.adtsys.ciee.company.contractplaces.exception.LocalContratoNotFoundException;
import br.com.adtsys.ciee.company.contractplaces.exception.NaoPodeDeletarLocalContratoAssinadoException;
import br.com.adtsys.ciee.company.contractplaces.exception.ValorCiAbaixoPermitidoException;
import br.com.adtsys.ciee.company.contractplaces.exception.ValorCiAcimaPermitidoException;
import br.com.adtsys.ciee.company.contractplaces.mapper.LocalContratoDropdownMapper;
import br.com.adtsys.ciee.company.contractplaces.model.ContractPlaces;
import br.com.adtsys.ciee.company.contractplaces.model.ContractPlacesAddressManagerView;
import br.com.adtsys.ciee.company.contractplaces.model.ContractPlacesDTO;
import br.com.adtsys.ciee.company.contractplaces.model.DadosLocalDTO;
import br.com.adtsys.ciee.company.contractplaces.model.ParametroEmpContratoResponse;
import br.com.adtsys.ciee.company.contractplaces.model.ParametroEmpEmpresaResponse;
import br.com.adtsys.ciee.company.contractplaces.model.ParametroEmpLocalContratoResponse;
import br.com.adtsys.ciee.company.contractplaces.model.ParametroEmpresaCabecalhoResponse;
import br.com.adtsys.ciee.company.contractplaces.repository.ContractPlaceSpecification;
import br.com.adtsys.ciee.company.contractplaces.repository.ContractPlacesRepository;
import br.com.adtsys.ciee.company.contractplaces.repository.imp.ContractPlacesRespositoryImpl;
import br.com.adtsys.ciee.company.contractplaces.repository.specification.LocalContratoDropdownSpecification;
import br.com.adtsys.ciee.company.contractplaces.share.exception.NaoPodeCriarAtualizarLocalContratoSemConfiguracaoCobranca;
import br.com.adtsys.ciee.company.contractplacesaddresses.ContractPlaceAddressNotFoundException;
import br.com.adtsys.ciee.company.contractplacesaddresses.model.ContractPlacesAddress;
import br.com.adtsys.ciee.company.contractplacesaddresses.repository.ContractPlacesAddressRepository;
import br.com.adtsys.ciee.company.contractplacesaddresses.share.model.Endereco;
import br.com.adtsys.ciee.company.contractplacesconfigcobranca.model.LocaisConfigCobranca;
import br.com.adtsys.ciee.company.contractplacesconfigcobranca.repository.LocaisConfigCobrancaRepository;
import br.com.adtsys.ciee.company.contractplacesrepresentative.model.ContractPlacesRepresentative;
import br.com.adtsys.ciee.company.contractrepresentative.repository.ContractRepresentativeRepository;
import br.com.adtsys.ciee.company.contratosUnificadoresCobrancas.service.ContratosUnificadoresCobrancasService;
import br.com.adtsys.ciee.company.contribution.exception.ContributionNotFoundException;
import br.com.adtsys.ciee.company.contribution.exception.InvalidCieeContributionException;
import br.com.adtsys.ciee.company.contribution.exception.InvalidContributionParamsException;
import br.com.adtsys.ciee.company.contribution.exception.InvalidManagementContributionException;
import br.com.adtsys.ciee.company.contribution.model.Contribution;
import br.com.adtsys.ciee.company.contributiondata.service.ContributionDataService;
import br.com.adtsys.ciee.company.exception.DefaultException;
import br.com.adtsys.ciee.company.exception.UnprocessableEntityException;
import br.com.adtsys.ciee.company.financeiro.service.FilaConfiguracaoCobrancaService;
import br.com.adtsys.ciee.company.person.model.Person;
import br.com.adtsys.ciee.company.phone.model.Phone;
import br.com.adtsys.ciee.company.preregistration.enumeration.PurposeTypeEnum;
import br.com.adtsys.ciee.company.preregistration.enumeration.TypePerson;
import br.com.adtsys.ciee.company.registrosbloqueados.enumeration.TipoRegistroBloqueado;
import br.com.adtsys.ciee.company.registrosbloqueados.service.RegistrosBloqueadosService;
import br.com.adtsys.ciee.company.representative.service.ClonadorRepresentanteService;
import br.com.adtsys.ciee.company.security.CurrentUserInfo;
import br.com.adtsys.ciee.company.totvs.service.ContratoTotvsService;
import br.com.adtsys.ciee.company.utils.CaepfCnoValidator;
import br.com.adtsys.ciee.company.utils.InscricaoEstadualValidador;
import br.org.ciee.kairos.architecture.base.service.impl.BaseServiceImpl;
import br.org.ciee.kairos.architecture.core.exception.BaseException;
import br.org.ciee.kairos.architecture.core.exception.resource.ResourceNotFoundException;
import br.org.ciee.kairos.architecture.data.procedures.DesativarCaseSensitive;
import br.org.ciee.kairos.architecture.data.procedures.GeneralProcedures;
import br.org.ciee.kairos.architecture.security.component.JwtRequestInfo;
import br.org.ciee.kairos.architecture.security.model.UserTypeEnum;
import br.org.ciee.kairos.logs.integracoes.enums.TipoEnvio;
import lombok.SneakyThrows;
import lombok.extern.log4j.Log4j2;

@Service
@Log4j2
public class ContractPlacesService extends BaseServiceImpl<ContractPlaces> {

	private static final String PERMISSAO_ADITIVO_JOVEM_TALENTO = "alt_contr_jov_tal";

	private static final int QTD_POR_PAGINA = 1000;

	@Autowired
	private ContractPlacesRepository contractPlacesRepository;

	@Autowired
	private ContractPlacesRespositoryImpl contractPlacesRepositoryImpl;

	@Autowired
	private ContractInfoRepository contractInfoRepository;

	@Autowired
	private ContractService contractService;

	@Autowired
	private ContributionDataService contributionDataService;

	@Autowired
	private CurrentUserInfo currentUserInfo;

	@Autowired
	private ProcuradorDadosEmpresaParticipanteContratoService procurador;

	@PersistenceContext
	private EntityManager entityManager;

	@Autowired
	private GeneralProcedures generalProcedures;

	@Autowired
	private ContractSettingsRepository contractSettingsRepository;

	@Autowired
	private ContractRepresentativeRepository contractRepresentativeRepository;

	@Autowired
	private ClonadorRepresentanteService clonadorRepresentante;

	@Autowired
	private FilaConfiguracaoCobrancaService filaConfiguracaoCobrancaService;

	@Autowired
	private LocalContratoDropdownMapper mapper;

	@Autowired
	private ContractPlacesAddressRepository contractPlacesAddressRepository;

	@Autowired
	private JwtRequestInfo jwtRequestInfo;

	@Autowired
	private ContratosUnificadoresCobrancasService contratosUnificadoresCobrancasService;

	@Autowired
	private ContractPlaceBlockingReasonRepository contractPlaceBlockingReasonRepository;

	@Autowired
	ClassCouncilRepository classCouncilRepository;

	@Autowired
	private ConfiguracaoCobrancaRepository configuracaoCobrancaRepository;

	@Autowired
	private LocaisConfigCobrancaRepository locaisConfigCobrancaRepository;
	
	@Autowired
	private CarteiraRepository carteiraRepository;
	
	@Autowired
	private ContratoTotvsService contratoTotvsService;
	
	@Autowired
	private RegistrosBloqueadosService registrosBloqueadosService;

	@Override
	protected void prePersist(ContractPlaces model) throws BaseException {
		validaRegrasLocalContrato(model);
		if(Objects.nonNull(model.getPhones())) {
			model.getPhones().stream().filter(fone -> Objects.nonNull(fone))
			.forEach(telefone -> registrosBloqueadosService.validarRegistroBloqueado(
					String.format("%s%s", telefone.getAreaCode(), telefone.getNumber()),
					TipoRegistroBloqueado.TELEFONE));
		}
		model.setStatus(defineStatusLocalContrato(model));
	}

	@Override
	@SneakyThrows({ BaseException.class, JsonProcessingException.class })
	public ContractPlaces save(ContractPlaces model) {
		validaInscricaoEstadual(model);
		validarCaepfCno(model);		

		validacaoJovemTalento(model);

		model.setStatus(defineStatusLocalContrato(model));

		Boolean permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado = this.contratosUnificadoresCobrancasService
				.validarSeContratoEstaUnificadoPorLocalContrato(model);

		if (permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado) {
			this.saveUnificacao(model);
		} else {
			this.saveSemUnificacao(model);
		}

		ContractPlaces contractPlaces = super.save(model);
		
		return contractPlaces;
	}

	@SneakyThrows({ ConfiguracaoCobrancaNotFoundException.class })
	public ContractPlaces saveNovoLocalContrato(ContractPlaces model) {

		Long idConfiguracaoCobranca = model.getIdConfiguracaoCobranca();

		if (Objects.isNull(idConfiguracaoCobranca)) {
			throw new ConfiguracaoCobrancaNotFoundException();
		}

		validaInformacoesConfiguracaoCobranca(idConfiguracaoCobranca);

		ContractPlaces novoLocalContrato = save(model);

		criaVinculoLocaisConfigCobranca(idConfiguracaoCobranca, novoLocalContrato);

		return novoLocalContrato;
	}

	private void criaVinculoLocaisConfigCobranca(Long idConfiguracaoCobranca, ContractPlaces novoLocalContrato) {
		LocaisConfigCobranca locaisConfigCobranca = locaisConfigCobrancaRepository.findById(novoLocalContrato.getId())
				.orElseGet(() -> LocaisConfigCobranca.builder().idLocalContrato(novoLocalContrato.getId()).build());
		locaisConfigCobranca.setIdConfiguracaoCobranca(idConfiguracaoCobranca);
		locaisConfigCobrancaRepository.save(locaisConfigCobranca);
	}

	public ContractPlaces saveUnificacao(ContractPlaces model) throws BaseException, JsonProcessingException {
		validacaoContratoUnificado(model);

		Long idConfiguracaoCobranca = model.getIdConfiguracaoCobranca();

		if (Objects.isNull(model.getContractPlacesRepresentatives())
				|| model.getContractPlacesRepresentatives().isEmpty()) {
			this.atribuirRepresentantesDoContrato(model);
		}

		filaConfiguracaoCobrancaService.salvarFilaConfiguracaoCobranca(model);

		if (Objects.isNull(idConfiguracaoCobranca)) {
			try {
				this.contratosUnificadoresCobrancasService
						.enfileirarConfiguracaoCobrancaTotvs(this.contratosUnificadoresCobrancasService
								.buscarIdConfiguracaoCobrancaUnificador(model.getContract().getId()));
			} catch (JsonProcessingException e) {
				throw new RuntimeException(e.getMessage());
			}
		}

		return model;
	}

	public ContractPlaces saveSemUnificacao(ContractPlaces model) throws JsonProcessingException {

		if (Objects.isNull(model.getContractPlacesRepresentatives())
				|| model.getContractPlacesRepresentatives().isEmpty()) {
			this.atribuirRepresentantesDoContrato(model);
		}

		filaConfiguracaoCobrancaService.salvarFilaConfiguracaoCobranca(model);

		return model;
	}

	private void validacaoJovemTalento(ContractPlaces model) throws BaseException {
		validacaoContratoJovemTalento(model.getContract().getId(), model.getJovemTalento());
	}

	private void validacaoAlteracaoJovemTalento(ContractPlaces model) throws BaseException {

		ContractPlaces localContrato = contractPlacesRepository.findById(model.getId())
				.orElseThrow(() -> new LocalContratoNotFoundException("Não foi encontrado local de contrato"));

		validacaoContratoJovemTalento(localContrato.getContract().getId(), model.getJovemTalento());

		Boolean jovemTalentoAlterado = BooleanUtils.toBoolean(model.getJovemTalento()) != BooleanUtils
				.toBoolean(localContrato.getJovemTalento());

		if (!currentUserInfo.hasAuthority(PERMISSAO_ADITIVO_JOVEM_TALENTO) && jovemTalentoAlterado) {
			throw new ContractPlaceBlockingReasonException(
					"Esta alteração necessita de permissão específica para realização");
		}
	}

	private void validacaoContratoJovemTalento(Long idContrato, Boolean jovemTalento) throws BaseException {

		JovemTalentoDTO dto = contractSettingsRepository.findByContractIdJovemTalentoDTO(idContrato)
				.orElseThrow(() -> new ContractPlaceBlockingReasonException("Não foi encontrado um contrato"));

		if (BooleanUtils.isTrue(jovemTalento) && !DocumentType.PROG_JOV_TALENTO.equals(dto.getType())
				&& !dto.getJovemTalento()) {
			throw new ContractPlaceBlockingReasonException("Esse contrato não permite programa jovem talento");
		}
	}

	@SneakyThrows
	private void atribuirRepresentantesDoContrato(ContractPlaces model) {
		if (!CollectionUtils.isEmpty(contractRepresentativeRepository
				.findAllByContractIdAndRepresentative_phonesIsNull(model.getContract().getId()))) {
			throw new ContractPlaceBlockingReasonException(
					"É necessário ter telefones para os representantes do contrato para incluir um local de contrato.");
		}
		List<ContractPlacesRepresentative> representantes = new ArrayList<ContractPlacesRepresentative>();
		contractRepresentativeRepository.findAllByContractId(model.getContract().getId())
				.forEach(contractRepresentative -> {
					representantes.add(ContractPlacesRepresentative.builder().contractPlace(model)
							.representative(clonadorRepresentante
									.clonaRepresentante(contractRepresentative.getRepresentative(), model))
							.representativeType(contractRepresentative.getRepresentativeType()).build());
				});
		model.setContractPlacesRepresentatives(representantes);
	}

	private void validaMultiEmpresaAtiva(ContractPlaces model, Contract contract) {
		String documento = getDocumento(model);
		procurador.validaParticipanteAtivo(contract.getId(), documento);
	}

	private String getDocumento(ContractPlaces model) {
		return model.getCompanyPersonType() == CompanyTypeEnum.INDEPENDENT_PROFESSIONAL ? model.getCpf()
				: model.getCnpj();
	}

	private void validaRegrasLocalContrato(ContractPlaces model) throws ResourceNotFoundException,
			LocalContatoSemDocumentoObrigatorioException, ContractPlacesCnpjValidateException,
			InvalidContractPlacesParamsException, InvalidContributionParamsException, InvalidCieeContributionException,
			ContributionNotFoundException, InvalidManagementContributionException, DefaultException,
			ValorCiAbaixoPermitidoException, ValorCiAcimaPermitidoException, CarteiraException  {
		if (!model.isNew() && Objects.isNull(model.getCompanyPersonType()) && Objects.isNull(model.getCpf())
				&& Objects.isNull(model.getCnpj())) {
			return;
		}

		Contract contract = getContract(model);
		validaTipoEmpresaDocumento(model, contract);
		validaMultiEmpresaAtiva(model, contract);
		try {
			configuraValidaValorCi(model, contract);
		} catch (IllegalAccessException e) {
			log.error(e);
			throw new DefaultException(String.format("Ocorreu um erro interno. Detalhes: ", e));
		}
	}

	private void configuraValidaValorCi(ContractPlaces model, Contract contract)
			throws InvalidContributionParamsException, InvalidCieeContributionException, ContributionNotFoundException,
			InvalidManagementContributionException, IllegalAccessException, ValorCiAbaixoPermitidoException,
			ValorCiAcimaPermitidoException {
		/*
		 * Se não tiver a permissão para informar CI diferenciada, então recebe valores
		 * padrões ou já salvos no banco se for edição
		 */
		if (!currentUserInfo.hasAuthority("aut_cidif_locco")) {
			if (model.isNew()) {
				model.setIsDifferentiatedCi(false);
				model.setAmountCi(null);
			} else {
				ContractPlaces contractPlacesDb = this.find(model.getId());
				model.setIsDifferentiatedCi(contractPlacesDb.getIsDifferentiatedCi());
				model.setAmountCi(contractPlacesDb.getAmountCi());
			}
		}

		if (model.getIsDifferentiatedCi() == null || !model.getIsDifferentiatedCi()) {
			return;
		}

		CompanyContractInfoAddress mainCompanyContractInfoAddress = CompanyContractInfoAddress
				.getMainAddress(contract.getMainCompanyContractInfo().getCompanyContractInfoAddresses());
		Optional<Contribution> contribution = this.contributionDataService.getContribution(contract,
				mainCompanyContractInfoAddress);

		if (contribution.isPresent()) {
			validaContribuicaoMinima(contribution.get(), model.getAmountCi());
			validaContribuicaoMaxima(contribution.get(), model.getAmountCi(), contract);
		}
	}

	private void validaContribuicaoMaxima(Contribution contribution, BigDecimal amountCi, Contract contract)
			throws ValorCiAcimaPermitidoException {
		if (PurposeTypeEnum.INTERNSHIP.equals(contract.getServiceType())) {
			if (amountCi.compareTo(contribution.getMaxValue()) > 0) {
				throw new ValorCiAcimaPermitidoException();
			}
		} else {
			BigDecimal maxContribution = BigDecimal.valueOf(9999.99);
			if (amountCi.compareTo(maxContribution) > 0) {
				throw new ValorCiAcimaPermitidoException();
			}
		}
	}

	private void validaContribuicaoMinima(Contribution contribution, BigDecimal amountCi)
			throws ValorCiAbaixoPermitidoException {
		if (amountCi.compareTo(contribution.getMinValue()) < 0 && !currentUserInfo.hasAuthority("aut_cidif_locco")) {
			throw new ValorCiAbaixoPermitidoException();
		}
	}

	private void validaTipoEmpresaDocumento(ContractPlaces model, Contract contract)
			throws LocalContatoSemDocumentoObrigatorioException, ContractPlacesCnpjValidateException,
			InvalidContractPlacesParamsException {
		if (Objects.isNull(model.getCompanyPersonType())) {
			throw new InvalidContractPlacesParamsException("O campo 'Empresa Jurídica ou PF / PL' é obrigatório");
		}

		if (TypePerson.INDEPENDENT_PROFESSIONAL.equals(contract.getPersonType())) {
			validaLocalContratoProfissionalLiberal(model, contract);
		} else {
			validaLocalContratoPessoaJuridica(model, contract);
		}
	}

	private Contract getContract(ContractPlaces model) throws ResourceNotFoundException {
		if (model.isNew()) {
			return contractService.find(model.getContract().getId());
		}

		if (Objects.isNull(model.getContract())) {
			ContractPlaces contractPlacesPersistedDb = find(model.getId());
			return contractPlacesPersistedDb.getContract();
		}

		return model.getContract();
	}

	private void validaLocalContratoPessoaJuridica(ContractPlaces contractPlace, Contract contract)
			throws LocalContatoSemDocumentoObrigatorioException, ContractPlacesCnpjValidateException,
			InvalidContractPlacesParamsException {
		if (contract.getComplementaryData().getAllowIndependentProfessional()) {
			if (CompanyTypeEnum.INDEPENDENT_PROFESSIONAL.equals(contractPlace.getCompanyPersonType())) {
				validaDadosProfissionalLiberal(contractPlace, contract);
			} else {
				validaDadosPessoaJuridica(contractPlace, contract);
			}
		} else {
			if (!CompanyTypeEnum.LEGAL_ENTITY.equals(contractPlace.getCompanyPersonType())) {
				throw new InvalidContractPlacesParamsException(
						"O campo 'Empresa Jurídica ou PF / PL' deve ser do tipo CNPJ");
			}

			validaDadosPessoaJuridica(contractPlace, contract);
		}
	}

	private void validaDadosPessoaJuridica(ContractPlaces contractPlace, Contract contract)
			throws LocalContatoSemDocumentoObrigatorioException, ContractPlacesCnpjValidateException {
		validaDocumentoObrigatorio(contractPlace.getCnpj());
		this.validaCNPJEmpresaParticipante(contractPlace.getCnpj(), contract);
	}

	private void validaLocalContratoProfissionalLiberal(ContractPlaces contractPlace, Contract contract)
			throws LocalContatoSemDocumentoObrigatorioException, ContractPlacesCnpjValidateException,
			InvalidContractPlacesParamsException {
		if (!CompanyTypeEnum.INDEPENDENT_PROFESSIONAL.equals(contractPlace.getCompanyPersonType())) {
			throw new InvalidContractPlacesParamsException(
					"O campo 'Empresa Jurídica ou PF / PL' deve ser do tipo CPF");
		}

		validaDadosProfissionalLiberal(contractPlace, contract);
	}

	private void validaDadosProfissionalLiberal(ContractPlaces contractPlace, Contract contract)
			throws LocalContatoSemDocumentoObrigatorioException, ContractPlacesCnpjValidateException,
			InvalidContractPlacesParamsException {
		validaDocumentoObrigatorio(contractPlace.getCpf());
		if (PurposeTypeEnum.INTERNSHIP.equals(contract.getServiceType())) {
			validaConselhoClasseAtivo(contractPlace);
		}
		this.validaCPFEmpresaParticipante(contractPlace.getCpf(), contract);
	}

	private void validaConselhoClasseAtivo(ContractPlaces contractPlace) throws InvalidContractPlacesParamsException {
		if (!contractPlace.getIsClassCouncilActive()) {
			throw new InvalidContractPlacesParamsException(
					"Para continuar o cadastro é necessário que o cadastro junto ao conselho de classe esteja ativo");
		}
	}

	private void validaDocumentoObrigatorio(String document) throws LocalContatoSemDocumentoObrigatorioException {
		if (StringUtils.isBlank(document)) {
			throw new LocalContatoSemDocumentoObrigatorioException();
		}
	}

	@Override
	protected void preUpdate(ContractPlaces model) throws BaseException {
		if(Objects.nonNull(model.getPhones())) {
			model.getPhones().stream().filter(fone -> Objects.nonNull(fone))
			.forEach(telefone -> registrosBloqueadosService.validarRegistroBloqueado(
					String.format("%s%s", telefone.getAreaCode(), telefone.getNumber()),
					TipoRegistroBloqueado.TELEFONE));
		}
		validaRegrasLocalContrato(model);
		super.preUpdate(model);
	}

	@Transactional
	public ContractPlaces patch(ContractPlaces model) throws BaseException {
		ContractPlaces localContratoCompleto = this.contractPlacesRepository.findById(model.getId()).orElse(model);
		boolean permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado = this.contratosUnificadoresCobrancasService
				.validarSeContratoEstaUnificadoPorLocalContrato(localContratoCompleto);
		if (permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado) {
			return this.patchUnificacao(localContratoCompleto);
		}
		return this.patchSemUnificacao(model);
	}

	@Transactional
	public ContractPlaces patchSemUnificacao(ContractPlaces model) throws BaseException {

		validaInscricaoEstadual(model);
		validarCaepfCno(model);
		
		if(Objects.nonNull(model.getPhones())) {
			model.getPhones().stream().filter(fone -> Objects.nonNull(fone))
			.forEach(telefone -> registrosBloqueadosService.validarRegistroBloqueado(
					String.format("%s%s", telefone.getAreaCode(), telefone.getNumber()),
					TipoRegistroBloqueado.TELEFONE));
		}

		validacaoAlteracaoJovemTalento(model);
		updateAttributesNotFilled(model);
		ContractPlaces modelFromDB = find(model.getId());
		atualizarDadosEntidade(model, modelFromDB);
		validaBloqueioLocalContrato(modelFromDB);
		ContractPlaces patch = contractPlacesRepository.save(modelFromDB);

		Optional.ofNullable(model.getIdConfiguracaoCobranca()).ifPresent(idCobranca -> {
			criaVinculoLocaisConfigCobranca(idCobranca, modelFromDB);
			log.info("PATCH: AValidando informações para salvar no redis - Local: {} e Configuração cobrança: {}",
					modelFromDB.getId(), idCobranca);
			filaConfiguracaoCobrancaService.salvarFilaConfiguracaoCobranca(modelFromDB);
		});

		validaSituacaoEnderecoConfigCobrancaFila(modelFromDB);

		return patch;
	}

	private void atualizarDadosEntidade(ContractPlaces model, ContractPlaces modelFromDB) {
		ClassCouncil conselhoClasse = null;
		if (Objects.nonNull(model.getClassCouncil()) && Objects.nonNull(model.getClassCouncil().getId())) {
			conselhoClasse = this.classCouncilRepository.findById(model.getClassCouncil().getId())
					.orElseThrow(() -> new ClassCouncilNotFoundException());
		}
		validarIdCarteira(model);
		modelFromDB.setActivity(model.getActivity());
		modelFromDB.setAmountCi(model.getAmountCi());
		modelFromDB.setCompanyType(model.getCompanyType());
		modelFromDB.setIsContractAdmin(model.getIsContractAdmin());
		modelFromDB.setIsDifferentiatedCi(model.getIsDifferentiatedCi());
		modelFromDB.setMunicipalInscription(model.getMunicipalInscription());
		modelFromDB.setSite(model.getSite());
		modelFromDB.setState(model.getState());
		modelFromDB.setStateInscription(model.getStateInscription());
		modelFromDB.setFreeStateInscription(model.getFreeStateInscription());
		modelFromDB.setBirthDate(model.getBirthDate());
		modelFromDB.setCei(model.getCei());
		modelFromDB.setCpf(model.getCpf());
		modelFromDB.setName(model.getName());
		modelFromDB.setCnpj(model.getCnpj());
		modelFromDB.setCompanyName(model.getCompanyName());
		modelFromDB.setTradingName(model.getTradingName());
		modelFromDB.setCompanyPersonType(model.getCompanyPersonType());
		modelFromDB.setStatus(model.getStatus());
		modelFromDB.setIsClassCouncilActive(model.getIsClassCouncilActive());
		modelFromDB.setClassCouncil(conselhoClasse);
		modelFromDB.setCouncilNumber(model.getCouncilNumber());
		modelFromDB.setRegisterValidity(model.getRegisterValidity());
		modelFromDB.setJovemTalento(model.getJovemTalento());
		modelFromDB.setCaepf(model.getCaepf());
		modelFromDB.setCno(model.getCno());
		modelFromDB.setCompanyPorte(model.getCompanyPorte());
		modelFromDB.setDescricaoLocal(model.getDescricaoLocal());
		modelFromDB.setCarteiraConsultor(model.getCarteiraConsultor());
	}
	

	@Transactional
	public ContractPlaces patchUnificacao(ContractPlaces model) throws BaseException {

		validaInscricaoEstadual(model);
		validarCaepfCno(model);

		validacaoAlteracaoJovemTalento(model);

		if (Objects.isNull(model.getContract())) {
			model.setContract(contractPlacesRepository.buscarContratoPorLocalContrato(model.getId()));
		}

		ContractPlaces localContrato = this.find(model.getId());
		ContractPlacesEnum ativo = localContrato.getStatus();

		if (ativo.equals(ContractPlacesEnum.ACTIVE)) {
			validacaoContratoUnificado(model);
		}

		updateAttributesNotFilled(model);
		ContractPlaces modelFromDB = find(model.getId());
		atualizarDadosEntidade(model, modelFromDB);
		validaBloqueioLocalContrato(modelFromDB);
		ContractPlaces patch = contractPlacesRepository.save(modelFromDB);

		Long idConfiguracaoCobranca = model.getIdConfiguracaoCobranca();

		Optional.ofNullable(model.getIdConfiguracaoCobranca()).ifPresent(idCobranca -> {
			criaVinculoLocaisConfigCobranca(idCobranca, modelFromDB);
			log.info("PATCH: Validando informações para salvar no redis - Local: {} e Configuração cobrança: {}",
					modelFromDB.getId(), idCobranca);
			filaConfiguracaoCobrancaService.salvarFilaConfiguracaoCobranca(modelFromDB);
		});

		validaSituacaoEnderecoConfigCobrancaFila(modelFromDB);

		boolean permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado = this.contratosUnificadoresCobrancasService
				.validarSeContratoEstaUnificadoPorLocalContrato(model);
		if (Objects.isNull(idConfiguracaoCobranca) && ativo.equals(ContractPlacesEnum.ACTIVE)
				&& !permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado) {
			try {
				this.contratosUnificadoresCobrancasService
						.enfileirarConfiguracaoCobrancaTotvs(this.contratosUnificadoresCobrancasService
								.buscarIdConfiguracaoCobrancaUnificador(model.getContract().getId()));
			} catch (JsonProcessingException e) {
				throw new RuntimeException(e.getMessage());
			}
		}

		return patch;
	}

	private void updateAttributesNotFilled(ContractPlaces model) throws BaseException {
		if (!model.isNew() && Objects.isNull(model.getCompanyPersonType()) && Objects.isNull(model.getCpf())
				&& Objects.isNull(model.getCnpj())) {
			return;
		}

		ContractPlaces modelFromDB = find(model.getId());
		Boolean isDifferentiatedCi = model.getIsDifferentiatedCi();

		if (nonNull(isDifferentiatedCi) && !isDifferentiatedCi) {
			modelFromDB.setAmountCi(null);
			model.setAmountCi(null);
		}

		if (Objects.isNull(model.getActivity())) {
			modelFromDB.setActivity(null);
		} else {
			modelFromDB.setActivity(model.getActivity());
		}

		if (Objects.isNull(model.getCompanyType())) {
			modelFromDB.setCompanyType(null);
		}
	}

	public Page<ContractPlaces> search(Pageable pageable, ContractPlacesDTO contractPlacesDTO) {
		ContractPlaceSpecification specification = new ContractPlaceSpecification(contractPlacesDTO);
		return this.findBySpecification(specification, pageable);
	}

	public Page<ContractPlacesAddressManagerView> searchFull(Pageable pageable, ContractPlacesDTO contract) {
		return this.contractPlacesRepositoryImpl.search(contract, pageable);
	}

	public List<ContractPlaces> findByContract(Long id) {
		return contractPlacesRepository.findByContractId(id);
	}

	@Override
	protected void preDelete(ContractPlaces model) throws BaseException {
		Contract contrato = model.getContract();

		if (!contratoPossuiDoisOuMaisLocaisDeContrato(contrato)) {
			throw new ContratoDevePossuirNoMinimoUmLocalException("");
		}

		if (contractService.contratoEstaAssinadoEArquivado(contrato)) {
			throw new NaoPodeDeletarLocalContratoAssinadoException("");
		}
	}

	/**
	 * Retorna true se o contrato possui mais de um local cadastrado
	 * <p>
	 * (Não deve ser possível deletar o último local do contrato sempre deve haver
	 * ao menos um local https://cieebr.atlassian.net/browse/PK-4734)
	 */
	private boolean contratoPossuiDoisOuMaisLocaisDeContrato(Contract contrato) {
		List<ContractPlaces> locaisDeContrato = this.contractPlacesRepository.findByContract(contrato);
		return locaisDeContrato != null && locaisDeContrato.size() >= 2;
	}

	private boolean contratoPossuiUmOuMaisLocaisDeContrato(Contract contrato) {
		List<ContractPlaces> locaisDeContrato = this.contractPlacesRepository.findByContract(contrato);
		return locaisDeContrato != null && locaisDeContrato.size() >= 1;
	}

	private void validaCNPJEmpresaParticipante(String cnpj, Contract contrato)
			throws ContractPlacesCnpjValidateException {

		List<ContractInfo> contratoParticipantes = new ArrayList<ContractInfo>();

		if (this.contratoPossuiUmOuMaisLocaisDeContrato(contrato)) {
			contratoParticipantes
					.addAll(contractInfoRepository.findByCNPJBaseAndContractId(cnpj.substring(0, 8), contrato));
		} else {
			contratoParticipantes.addAll(contractInfoRepository.findByCNPJAndContractId(cnpj, contrato));
		}

		if (contratoParticipantes.isEmpty()) {
			throw new ContractPlacesCnpjValidateException("CNPJ", "Esta empresa não faz parte do contrato.");
		}
	}

	private void validaCPFEmpresaParticipante(String cpf, Contract contrato)
			throws ContractPlacesCnpjValidateException {
		List<ContractInfo> contratos = contractInfoRepository.findByCPFAndContractId(cpf, contrato);
		if (contratos.isEmpty())
			throw new ContractPlacesCnpjValidateException("CPF", "Esta empresa não faz parte do contrato.");
	}

	private boolean localContratoComDadosPendentes(ContractPlaces localContrato) {
		List<ContractPlacesAddress> enderecoLocalContrato = localContrato.getContractPlacesAddresses();
		List<Person> contatoLocalContrato = localContrato.getContacts();
		boolean localSemEndereco = enderecoLocalContrato == null || enderecoLocalContrato.isEmpty();
		boolean localSemContato = contatoLocalContrato == null || contatoLocalContrato.isEmpty();
		return localSemEndereco || localSemContato;
	}

	public ContractPlacesEnum defineStatusLocalContrato(ContractPlaces localContrato) throws ResourceNotFoundException {
		if (!localContrato.getIsContractAdmin() && this.localContratoComDadosPendentes(localContrato))
			return ContractPlacesEnum.PENDENTE;
		return ContractPlacesEnum.ACTIVE;
	}

	@Override
	protected void postUpdate(ContractPlaces model) throws BaseException {
		String statusAnteriorLocalContrato = model.getStatus().name();
		model.setStatus(defineStatusLocalContrato(model));
		super.postUpdate(model);
	}

	public Long count(Long contractId) {
		return contractPlacesRepository.countByContractId(contractId);
	}

	public List<ContractPlaces> getListaLocaisContratoPorIds(List<Long> idsLocaisContrato) {

		List<ContractPlaces> locaisContrato = new ArrayList<ContractPlaces>();

		Collection<List<Long>> particionar = this.particionar(idsLocaisContrato, QTD_POR_PAGINA);

		particionar.forEach(lista -> {
			locaisContrato.addAll(contractPlacesRepository.findByIdIn(Sets.asSet(lista)));
		});

		return locaisContrato;
	}

	public LocalDate procuraDataNascimentoParticipante(ContractInfo dados, Long idContrato) {
		if (dados.getBirthDate() != null) {
			return dados.getBirthDate();
		}
		Optional<ContractPlaces> optParticipante = this.contractPlacesRepository
				.findByCpfAndContractId(dados.getCompany().getCpf(), idContrato).stream()
				.filter(participante -> participante.getBirthDate() != null).findFirst();
		return optParticipante.map(ContractPlaces::getBirthDate).orElse(null);
	}

	public List<LocalContratoDropdownDTO> buscarParaDropdown(String filtro, Long idContrato, Pageable pageable)
			throws ContractPlaceAddressNotFoundException, DefaultException {
		this.generalProcedures.accentAndCaseInsensitive(true);
		List<LocalContratoDropdownDTO> result = Arrays.asList();
		try {
			result = contractPlacesRepository
					.findAll(new LocalContratoDropdownSpecification(idContrato, jwtRequestInfo.getUserId(),
							jwtRequestInfo.isUserType(UserTypeEnum.COMPANY), filtro), pageable)
					.stream().map(lc -> mapper.mapResponse(lc)).collect(Collectors.toList());
		} catch (EntityNotFoundException e) {
			log.error(String.format("Ocorreu um erro do tipo EntityNotFoundException ao "
					+ "tentar buscar por ContractPlaces para dropdown: %s", e.getMessage()));
			throw new ContractPlaceAddressNotFoundException();
		} catch (Exception e) {
			log.error(String.format(
					"Ocorreu um erro do tipo Exception ao " + "tentar buscar por ContractPlaces para dropdown: %s",
					e.getMessage()));
			if (e.getCause().getClass().equals(EntityNotFoundException.class)) {
				throw new ContractPlaceAddressNotFoundException();
			}
			throw new DefaultException("Alguns dados não foram encontrado!");
		} finally {
			this.generalProcedures.accentAndCaseInsensitive(false);
		}
		return result;
	}

	public ParametroEmpresaCabecalhoResponse informacoesCabecalhoParametroEmpresa(Long idLocalContrato) {

		ParametroEmpresaCabecalhoResponse cabecalho = new ParametroEmpresaCabecalhoResponse();

		ContractPlaces contractPlace = this.find(idLocalContrato);

		Contract contract = contractPlace.getContract();

		CompanyContractInfo mainCompanyContractInfo = contract.getMainCompanyContractInfo();

		ParametroEmpEmpresaResponse empresaResponse = contractService.criarEmpresaResponse(contract,
				mainCompanyContractInfo.getCompany(), mainCompanyContractInfo);
		ParametroEmpContratoResponse contratoResponse = contractService.criarContratoResponse(contract,
				mainCompanyContractInfo);
		ParametroEmpLocalContratoResponse localContratoResponse = criarLocalContratoResponse(contractPlace);

		return ParametroEmpresaCabecalhoResponse.builder().empresa(empresaResponse).contrato(contratoResponse)
				.localContrato(localContratoResponse).build();
	}

	public ParametroEmpLocalContratoResponse criarLocalContratoResponse(ContractPlaces contractPlace) {

		List<ContractPlacesAddress> contractPlacesAddresses = contractPlace.getContractPlacesAddresses();

		if (CollectionUtils.isEmpty(contractPlacesAddresses))
			return null;

		contractPlacesAddresses.sort(comparing(ContractPlacesAddress::getCreationDate).reversed());

		ContractPlacesAddress contractPlacesAddress = contractPlacesAddresses.stream().filter(c -> c.getMainAddress())
				.findFirst().orElse(contractPlacesAddresses.get(0));

		ParametroEmpLocalContratoResponse localContratoResponse = Optional.ofNullable(contractPlacesAddress)
				.map(ContractPlacesAddress::getAddress).map(this::converterEndereco)
				.orElseGet(ParametroEmpLocalContratoResponse::new);

		localContratoResponse.setAtivo(BooleanUtils.isFalse(contractPlace.getBlocked()));

		return localContratoResponse;

	}

	private ParametroEmpLocalContratoResponse converterEndereco(Address address) {
		return ParametroEmpLocalContratoResponse.builder().tipoLogradouro(address.getType())
				.endereco(address.getAddress()).numero(address.getNumber()).bairro(address.getNeighborhood())
				.complemento(address.getComplement()).cep(address.getZipCode()).cidade(address.getCity())
				.estado(address.getState()).build();
	}

	private String pegarTipoServico(Contract contract) {
		return nonNull(contract.getServiceType()) ? contract.getServiceType().getPurposeType() : null;
	}

	private String pegarTipoDocumento(ContractSettings contractSettings) {
		return nonNull(contractSettings.getDocumentType()) ? contractSettings.getDocumentType().getDescription() : null;
	}

	public List<ContractPlaces> findByContractIdAndIdIn(Long idContrato, List<Long> idLocais) {
		return this.contractPlacesRepository.findByContractIdAndIdIn(idContrato, idLocais);
	}

	public List<ContractPlaces> findByContractId(Long idContrato) {
		return this.contractPlacesRepository.findByContractId(idContrato);
	}

	public List<ContractPlaces> findByContractIdAndIdNotIn(Long idContrato, List<Long> idLocais) {
		return this.contractPlacesRepository.findByContractIdAndIdNotIn(idContrato, idLocais);
	}

	@DesativarCaseSensitive
	public Page<ContractPlaces> buscarLocaisContratoPorIdsEmpresa(List<Long> idsEmpresa, String filtro,
			Pageable pageable) {
		return this.contractPlacesRepository.findAll(new LocalContratoDropdownSpecification(idsEmpresa, filtro),
				pageable);
	}

	@Override
	protected void postPersist(ContractPlaces model) throws BaseException {
		super.postPersist(model);
	}

	@Override
	public ContractPlaces find(Long idLocalContrato) {
		return contractPlacesRepository.findById(idLocalContrato).orElseThrow(() -> new LocalContratoNotFoundException(
				"Não foi encontrado Local Contrato com id " + idLocalContrato));
	}

	@Transactional
	public void setupContractPlacesAddress(CompanyContractInfoAddress compantContractInfoAddress, Long idContrato) {

		List<ContractPlaces> contractsPlaces = this.findByContractId(idContrato);

		Contract contract = this.contractService.findById(idContrato);

		ContractStatusEnum situacao = contract.getStatus();

		if (!contractsPlaces.isEmpty() && contractsPlaces.size() == 1 && Objects.nonNull(compantContractInfoAddress)
				&& (situacao.equals(ContractStatusEnum.PENDING) || situacao.equals(ContractStatusEnum.IN_PROGRESS))) {

			ContractPlaces contractPlace = contractsPlaces.stream().findFirst().orElse(null);

			ContractPlacesAddress contractPlacesAdress = contractPlace.getContractPlacesAddress();
			contractPlacesAdress.setAddress(compantContractInfoAddress.getAddress());
			contractPlacesAdress.setCieeUnitId(compantContractInfoAddress.getCieeUnitId());
			contractPlacesAdress.setManagementId(compantContractInfoAddress.getManagementId());
			contractPlacesAdress.setCieeUnitDescription(compantContractInfoAddress.getCieeUnitDescription());
			contractPlacesAdress.setManagementDescription(compantContractInfoAddress.getManagementDescription());
			contractPlacesAddressRepository.save(contractPlacesAdress);
		}

	}

	private <T extends Collection<X>, X> Collection<List<X>> particionar(T lista, Integer tamanho) {
		final AtomicInteger counter = new AtomicInteger();
		return lista.stream().collect(Collectors.groupingBy(it -> counter.getAndIncrement() / tamanho)).values();
	}

	private void validaInscricaoEstadual(ContractPlaces model) throws ContractPlacesInscricaoEstadualException {
		InscricaoEstadualValidador.validate(model.getStateInscription(), model.getState(),
				model.getFreeStateInscription());
	}

	private void validacaoContratoUnificado(ContractPlaces model) {
		boolean permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado = this.contratosUnificadoresCobrancasService
				.validarSeContratoEstaUnificadoPorLocalContrato(model);
		if (!permiteContinuarSemConfiguracaoCobrancaPropriaPorEstarUnificado
				&& Objects.isNull(model.getIdConfiguracaoCobranca())) {
			throw new NaoPodeCriarAtualizarLocalContratoSemConfiguracaoCobranca(
					"O contrato não possuí configuração de cobrança unificada e não foi escolhida uma configuração de cobrança do próprio contrato, não é possível continuar.");
		}
	}

	public Endereco buscarInformacaoEnderecoLocal(Long idLocalContrato) {

		ContractPlaces contractPlace = this.find(idLocalContrato);
		Address address = contractPlace.getContractPlacesAddress().getAddress();
		if (Objects.isNull(address)) {
			return null;
		}
		return Endereco.builder().id(address.getId()).tipo(address.getType()).endereco(address.getAddress())
				.numero(address.getNumber()).bairro(address.getNeighborhood()).complemento(address.getComplement())
				.cep(address.getZipCode()).cidade(address.getCity()).estado(address.getState())
				.latitude(address.getLatitude()).longitude(address.getLongitude()).build();

	}

	@SneakyThrows({ ResourceNotFoundException.class })
	public List<Phone> patchPhones(Long contractPlaceId, List<Phone> phones) {
		ContractPlaces contract = find(contractPlaceId);
		phones.stream().forEach(telefone -> registrosBloqueadosService.
				validarRegistroBloqueado(String.format("%s%s", telefone.getAreaCode(), telefone.getNumber()), TipoRegistroBloqueado.TELEFONE));
		contract.setPhones(phones);
		contract.setStatus(defineStatusLocalContrato(contract));
		validaBloqueioLocalContrato(contract);
		return contractPlacesRepository.save(contract).getPhones();
	}

	@SneakyThrows({ ResourceNotFoundException.class })
	public List<Person> patchContacts(Long contractPlaceId, List<Person> persons) {
		ContractPlaces contract = find(contractPlaceId);
		
		persons.stream()
				.forEach(pessoa -> pessoa.getPhones().stream()
						.forEach(telefone -> registrosBloqueadosService.validarRegistroBloqueado(
								String.format("%s%s", telefone.getAreaCode(), telefone.getNumber()),
								TipoRegistroBloqueado.TELEFONE)));
		
		contract.setContacts(persons);
		contract.setStatus(defineStatusLocalContrato(contract));
		validaBloqueioLocalContrato(contract);

		validaSituacaoEnderecoConfigCobrancaFila(contract);
		return contractPlacesRepository.save(contract).getContacts();
	}

	private void validaSituacaoEnderecoConfigCobrancaFila(ContractPlaces contractPlace) {
		if (Objects.nonNull(contractPlace.getContractPlacesAddress())
				&& ContractPlacesEnum.ACTIVE.equals(contractPlace.getStatus())) {
			filaConfiguracaoCobrancaService.enviarFilaConfiguracaoCobranca(contractPlace);
		}
	}

	private void validaBloqueioLocalContrato(ContractPlaces contractPlace) {
		List<ContractPlaceBlockingReason> bloqueiosPendentesLocaisContrato = contractPlaceBlockingReasonRepository
				.findByContractPlace(contractPlace).stream().filter(b -> Objects.nonNull(b)
						&& BooleanUtils.isFalse(b.getDeleted()) && Objects.isNull(b.getUnblockingComment()))
				.collect(Collectors.toList());

		contractPlace.setBlocked(!bloqueiosPendentesLocaisContrato.isEmpty());
	}

	private void validarCaepfCno(ContractPlaces model) throws UnprocessableEntityException {
		if (model.getCompanyPersonType().equals(CompanyTypeEnum.INDEPENDENT_PROFESSIONAL)) {
			if (Objects.nonNull(model.getCaepf()) || Objects.nonNull(model.getCno())) {
				CaepfCnoValidator.validate(model.getCaepf(), model.getCno(), model.getCpf());
			}
		}
	}

	@SneakyThrows({ ConfiguracaoCobrancaNotFoundException.class, ConfiguracaoCobrancaException.class })
	private void validaInformacoesConfiguracaoCobranca(Long idConfiguracaoCobranca) {
		ConfiguracaoCobranca configuracaoCobranca = configuracaoCobrancaRepository.findById(idConfiguracaoCobranca)
				.orElseThrow(() -> new ConfiguracaoCobrancaNotFoundException());
		if (BooleanUtils.isNotTrue(configuracaoCobranca.getSituacao())) {
			throw new ConfiguracaoCobrancaException("Configuração de cobrança está Inativa");
		}
	}

	public Boolean validaCnpjLocal(DadosLocalDTO dadosLocalDTO) {

		return this.contractPlacesRepository.existsByContractIdAndCnpjAndContractContractSettingsDocumentType(dadosLocalDTO.getIdContrato(), dadosLocalDTO.getCnpj(), DocumentType.APRENDIZ_PAULISTA);
	}
	
	public void validarRegistroBloqueado(String texto, TipoRegistroBloqueado tipo) {
		this.registrosBloqueadosService.validarRegistroBloqueado(texto, tipo);
	}
	
	  @SneakyThrows({CarteiraException.class})
	  private Long validarIdCarteira(ContractPlaces model){
	  	if(Objects.isNull(model.getCarteiraConsultor()) || Strings.isEmpty(model.getCarteiraConsultor().toString())) {
	  		return null;
	  	}
	  	return carteiraRepository.findById(model.getCarteiraConsultor()).map(Carteira::getId).orElseThrow(CarteiraException::new);
	  }

}
